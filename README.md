# xplan
codingcat learning plan

## 数据结构与算法

### 线性表

- [x]数组实现
- [x]链表实现

### 栈与队列

**栈**

>栈是一种特殊的线性表，只能从固定的方向进出，而且栈进出的基本原则是：先进栈的元素后出栈

*栈的基本特点*
- 先入后出，后入先出。
- 除头尾节点之外，每个元素有一个前驱，一个后继。

**队列**

> 队列是先进先出（FIFO, First-In-First-Out）的线性表

### 树与二叉树

- [python实现二叉树和它的七种遍历](http://blog.csdn.net/bone_ace/article/details/46718683)

- 树的遍历
- Tree 树
- Binary tree 二叉树
- Binary Search Tree 二叉查找树
- AVL 平衡二叉树
- Red–black tree 红黑树

### 图

- BFS 深度优先搜索
- DFS 广度优先搜索
- Dijkstra 最短路径算法
- Prim 最小生成树
- Kruskal 最小生成树

### 排序算法

- 冒泡排序
- 简单选择排序
- 直接插入排序
- 希尔排序
- 归并排序
- 快速排序
- 堆排序

### 字符串算法

- KMP 算法
- Boyer-Moore 算法


## 操作系统

### 进程管理

- 进程与线程
    - 什么是进程
    - 进程状态
    - 进程描述
    - 进程控制
    - 进程和线程
    - 线程分类
    - 多核和多线程
- 互斥与同步
    - 并发的原理
    - 互斥
    - 信号量
    - 管程
    - 消息传递
    - 读写问题
- 死锁与饥饿
    - 死锁原理
    - 死锁预防
    - 死锁避免
    - 死锁检测

### 处理器调度

- 长程调度
- 中程调度
- 短程调度
- 调度算法
- 虚拟内存

### 磁盘IO

- IO设备
- IO缓冲
- 磁盘调度

### 内存管理

- 内存分区
- 分页
- 分段
- 安全问题
- 内存管理
- 虚拟内存

### 文件系统

- 文件和文件系统
- 文件组织和访问
- B树
- 文件目录
- 文件共享
- 文件系统安全

### 计算机安全

- 计算机安全概念
- 入侵者
- 病毒、蠕虫与僵尸
- Rootkit
- 访问控制
- 入侵检测
- 恶意软件防御
- 处理缓冲区溢出攻击


### 分布式系统

- 面向服务的体系结构
- 分布式消息传递
- 远程过程调用
- 集群


## 计算机网络

### 网络分层

- OSI七层网络模型
- TCP/IP


## 信息安全

### 对称加密

- 对称加密原理
- 对称分组加密算法
    - 三重DES
- 随机数和伪随机数
- 流密码和RC4

### 公钥密码和消息认证
- 消息认证方法
- 安全散列函数(hash)
- 消息认证码
    - HMAC
    - 基于分组密码的MAC
- 公钥私钥原理
- 公钥秘密算法
    - RSA公钥秘密算法
    - Diffie-Hellman密钥交换
- 数字签名

## Git操作

- http://www.bootcss.com/p/git-guide/
- https://git-scm.com/doc
- https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000

## vagrant

- https://imququ.com/post/vagrantup.html
- http://blog.leanote.com/post/wuliang/Max-Os-Virtualbox
- http://www.jianshu.com/p/7747c31012f8

## docker

## 系统架构

### 缓存相关

以下内容来自: http://www.jianshu.com/p/3c111e4719b8

**缓存穿透**
> 缓存穿透是说访问一个缓存中没有的数据，但是这个数据数据库中也不存在。普通思路下我们没有从数据库中拿到数据是不会触发加缓存操作的。这时如果是有人恶意攻击，大量的访问就会透过缓存直接打到数据库，对后端服务和数据库做成巨大的压力甚至宕机。

`解决方案`

- 缓存空对象。如果缓存未命中，而数据库中也没有这个对象，则可以缓存一个空对象到缓存。如果使用Redis，这种key需设置一个较短的时间，以防内存浪费。
- 缓存预测。预测key是否存在。如果缓存的量不大可以使用hash来判断，如果量大可以使用布隆过滤器来做判断。

**缓存并发**

> 缓存并发这个场景很容易解释：多个客户端同时访问一个没有在cache中的数据，这时每个客户端都会执行从DB加载数据set到缓存，就会造成缓存并发。

`解决方案`
- 缓存预热。提前把所有预期的热数据加到缓存。定位热数据还是比较复杂的事情，需要根据自己的服务访问情况去评估。这个方案只能减轻缓存并发的发生次数不能全部抵制。
- 缓存加锁。 如果多个客户端访问不存在的缓存时，在执行加载数据并set缓存这个逻辑之前先加锁，只能让一个客户端执行这段逻辑。

**缓存防雪崩**
> 缓存雪崩是缓存服务暂时不能提供服务，导致所有的请求都直接访问DB。

- 构建高可用的缓存系统。目前常用的缓存系统Redis和Memcache都支持高可用的部署方式，所以部署的时候不防先考虑是否要以高可用的集群方式部署。
- 限流。Netflix的Hystrix是非常不错的工具，在用缓存时不妨搭配它来使用。

### 网站架构

来自: http://www.jianshu.com/p/bf431f8159bd
